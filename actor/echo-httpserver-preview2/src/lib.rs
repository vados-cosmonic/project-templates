//! Echo Actor component, which compiles to WASI Preview 2

// wit-bindgen generates the traits and implementation that
// power WIT-based WASM development.
//
// To see what wit-bindgen generates, use [cargo expand](https://github.com/dtolnay/cargo-expand)
wit_bindgen::generate!({
    world: "echo",
    exports: {
        "wasi:http/incoming-handler": EchoActor
    }
});

use std::collections::HashMap;

// NOTE: the imports below are generated by wit-bindgen
use wasi::{
    http::http_types::{
        fields_entries, finish_outgoing_stream, incoming_request_consume, incoming_request_headers,
        incoming_request_method, incoming_request_path_with_query, new_fields,
        new_outgoing_response, outgoing_response_write, set_response_outparam, IncomingRequest,
        Method, ResponseOutparam,
    },
    io::streams::{blocking_read, write, StreamStatus},
};

use exports::wasi::http::incoming_handler::IncomingHandler;

use serde_json::json;

/// Echo (HTTP) actor
///
/// This unit struct will hold all implementations of
/// bindgen-derived traits for the WIT contract @ echo.wit
struct EchoActor;

/// Implementation of a wasi:http/incoming-handler that allows us to
/// handle HTTP requests
///
/// We use a slight specialization of wasi:http/incoming-handler -- [wasmcloud/wasi-http](https://github.com/wasmCloud/wasi-http)
impl IncomingHandler for EchoActor {
    fn handle(request: IncomingRequest, response: ResponseOutparam) {
        let method: String = incoming_request_method(request).as_str().into();

        // Retrieve path & query
        let path_and_query = incoming_request_path_with_query(request)
            .expect("failed to retrieve path and query from request");

        let paq = http::uri::PathAndQuery::from_maybe_shared(path_and_query)
            .expect("failed to parse path & query");

        // Retreive headers
        let headers: HashMap<String, String> = fields_entries(incoming_request_headers(request))
            .iter()
            .fold(HashMap::new(), |mut acc, (k, v)| {
                acc.insert(k.to_string(), String::from_utf8_lossy(v).into_owned());
                acc
            });

        // Retrieve request body
        let body = read_http_body(request);

        // Build and serialize the echo response
        let response_body: Vec<u8> = serde_json::to_string_pretty(&json!({
            "method": method,
            "path": paq.path(),
            "headers": &headers,
            "query_string": paq.query(),
            "body": &body,
        }))
        .map_err(|e| format!("failed to encode request body: {e}"))
        .expect("failed to encode request body")
        .into();

        // Build & write the response the response
        write_http_response(response, 200, &content_type_json(), response_body);
    }
}

// Augment the generated WIT-interface Method class to easily convert to a slice
impl Method {
    /// Get the string for a WIT HTTP method
    fn as_str(&self) -> &str {
        match self {
            Method::Connect => "CONNECT",
            Method::Delete => "DELETE",
            Method::Get => "GET",
            Method::Post => "POST",
            Method::Put => "PUT",
            Method::Patch => "PATCH",
            Method::Head => "HEAD",
            Method::Options => "OPTIONS",
            Method::Trace => "TRACE",
            Method::Other(s) => s,
        }
    }
}

/// Read a WIT-ified HTTP incoming request body
fn read_http_body(incoming_request: IncomingRequest) -> Vec<u8> {
    let incoming_stream =
        incoming_request_consume(incoming_request).expect("failed to consume incoming request");

    // Read the incoming stream completely
    let mut buf = Vec::with_capacity(4096); // 4kb chunks
    while let Ok((bytes, status)) = blocking_read(incoming_stream, 4096) {
        buf.extend(bytes);
        if status == StreamStatus::Ended {
            break;
        }
    }

    buf
}

/// Write a W HTTP response out, using WIT-driven (WASI) interfaces
fn write_http_response(
    response_outparam: ResponseOutparam,
    status_code: u16,
    headers: &[(String, Vec<u8>)],
    body: impl AsRef<[u8]>,
) {
    // Add headers
    let headers = new_fields(headers);

    // Create new outgoing response and related stream
    let outgoing_response =
        new_outgoing_response(status_code, headers).expect("failed to create response");
    let outgoing_stream =
        outgoing_response_write(outgoing_response).expect("failed to write outgoing response");

    // Write out repsonse body to outgoing stream
    write(outgoing_stream, body.as_ref()).expect("failed to write output to stream");
    finish_outgoing_stream(outgoing_stream);

    // Set the response on the param
    set_response_outparam(response_outparam, Ok(outgoing_response))
        .expect("failed to set response");
}

/// Helper that returns content type of a json response
fn content_type_json() -> [(String, Vec<u8>); 1] {
    [("Content-Type".into(), "application/json".into())]
}
